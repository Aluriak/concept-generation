from pyasp import asp
from functools import partial


METHODS_DEF = {met: met for met in (
    'false',
    'simple',
    'choice',
    'choice_noint',
    'choice_exp',
    'lit_hitzler',
)}


def method_simple_parallelized(context):
    yield from solve(['simple.lp', context], '--parallel-mode=4,split')
def method_choice_parallelized(context):
    yield from solve(['choice.lp', context], '--parallel-mode=4,split')


def build_methods() -> iter:
    """Create methods according to METHODS_DEF,
    then add it in global scope"""
    for name, filename in METHODS_DEF.items():
        filename = filename + '.lp'
        def wrapper(filename):
            def method_func(context):
                yield from solve([filename, context])
            return method_func
        method_func = wrapper(filename)
        method_func.__name__ = 'method_' + name
        globals()['method_' + name] = method_func


def build_derivatives() -> iter:
    """Create derivatives methods according to METHODS,
    then yield and add it in global scope"""
    for func, name in METHODS.items():
        def wrapper(func):
            def method_ans_func(context):
                return tuple(func(context))
            def method_sum_func(context):
                return sum(1 for answer in func(context))
            return method_ans_func, method_sum_func
        method_ans_func, method_sum_func = wrapper(func)
        method_ans_func.__name__ = 'method_ans_' + name
        method_sum_func.__name__ = 'method_sum_' + name
        globals()['method_ans_' + name] = method_ans_func
        globals()['method_sum_' + name] = method_sum_func
        yield ((method_ans_func, name), (method_sum_func, name))


def solve(files:iter, clasp_options='') -> iter:
    """Yield all solutions"""
    solver = asp.Gringo4Clasp(clasp_options=' -n 0 ' + clasp_options)
    yield from solver.run(list(files), collapseAtoms=False)


# collect all methods (including those that are not generated by build)
build_methods()
METHODS = {method: method.__name__[len('method_'):]
           for name, method in globals().items()
           if name.startswith('method_') and callable(method)}
METHOD_NAMES = frozenset(METHODS.values())

# collect all derivatives functions
METHODS_ANS, METHODS_SUM = map(dict, zip(*build_derivatives()))
